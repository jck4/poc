"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformStack = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = require("constructs");
const _tokens_1 = require("./_tokens");
const fs = require("fs");
const path = require("path");
const terraform_element_1 = require("./terraform-element");
const util_1 = require("./util");
const terraform_provider_1 = require("./terraform-provider");
const features_1 = require("./features");
const unique_1 = require("./private/unique");
const STACK_SYMBOL = Symbol.for('ckdtf/TerraformStack');
/**
 * @experimental
 */
class TerraformStack extends constructs_1.Construct {
    /**
     * @experimental
     */
    constructor(scope, id) {
        super(scope, id);
        this.rawOverrides = {};
        this.cdktfVersion = constructs_1.Node.of(this).tryGetContext('cdktfVersion');
        Object.defineProperty(this, STACK_SYMBOL, { value: true });
    }
    /**
     * @experimental
     */
    static isStack(x) {
        return x !== null && typeof (x) === 'object' && STACK_SYMBOL in x;
    }
    /**
     * @experimental
     */
    static of(construct) {
        return _lookup(construct);
        function _lookup(c) {
            if (TerraformStack.isStack(c)) {
                return c;
            }
            const node = constructs_1.Node.of(c);
            if (!node.scope) {
                throw new Error(`No stack could be identified for the construct at path '${constructs_1.Node.of(construct).path}'`);
            }
            return _lookup(node.scope);
        }
    }
    /**
     * @experimental
     */
    addOverride(path, value) {
        const parts = path.split('.');
        let curr = this.rawOverrides;
        while (parts.length > 1) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const key = parts.shift();
            // if we can't recurse further or the previous value is not an
            // object overwrite it with an object.
            const isObject = curr[key] != null && typeof (curr[key]) === 'object' && !Array.isArray(curr[key]);
            if (!isObject) {
                curr[key] = {};
            }
            curr = curr[key];
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastKey = parts.shift();
        curr[lastKey] = value;
    }
    /**
     * @experimental
     */
    getLogicalId(tfElement) {
        // wrap the allocation for future renaming support
        return this.allocateLogicalId(tfElement);
    }
    /**
     * (experimental) Returns the naming scheme used to allocate logical IDs.
     *
     * By default, uses
     * the `HashedAddressingScheme` but this method can be overridden to customize
     * this behavior.
     *
     * @param tfElement The element for which the logical ID is allocated.
     * @experimental
     */
    allocateLogicalId(tfElement) {
        const node = tfElement instanceof terraform_element_1.TerraformElement ? tfElement.constructNode : tfElement;
        const stack = tfElement instanceof terraform_element_1.TerraformElement ? tfElement.cdktfStack : this;
        let stackIndex;
        if (node.tryGetContext(features_1.EXCLUDE_STACK_ID_FROM_LOGICAL_IDS)) {
            stackIndex = node.scopes.indexOf(stack);
        }
        else {
            stackIndex = 0;
        }
        const components = node.scopes.slice(stackIndex + 1).map(c => constructs_1.Node.of(c).id);
        return components.length > 0 ? unique_1.makeUniqueId(components, node.tryGetContext(features_1.ALLOW_SEP_CHARS_IN_LOGICAL_IDS)) : '';
    }
    /**
     * @experimental
     */
    allProviders() {
        const providers = [];
        const visit = async (node) => {
            if (node instanceof terraform_provider_1.TerraformProvider) {
                providers.push(node);
            }
            for (const child of constructs_1.Node.of(node).children) {
                visit(child);
            }
        };
        visit(this);
        return _tokens_1.resolve(this, providers);
    }
    /**
     * @experimental
     */
    toTerraform() {
        const tf = {
            "//": {
                metadata: {
                    version: this.cdktfVersion,
                    stackName: constructs_1.Node.of(this).id,
                }
            }
        };
        const elements = terraformElements(this);
        const fragments = elements.map(e => _tokens_1.resolve(this, e.toTerraform()));
        for (const fragment of fragments) {
            util_1.deepMerge(tf, fragment);
        }
        util_1.deepMerge(tf, this.rawOverrides);
        return _tokens_1.resolve(this, tf);
    }
    /**
     * (experimental) Allows this construct to emit artifacts into the cloud assembly during synthesis.
     *
     * This method is usually implemented by framework-level constructs such as `Stack` and `Asset`
     * as they participate in synthesizing the cloud assembly.
     *
     * @experimental
     */
    onSynthesize(session) {
        const manifest = session.manifest;
        const stackManifest = manifest.forStack(this);
        const workingDirectory = path.join(session.outdir, stackManifest.workingDirectory);
        if (!fs.existsSync(workingDirectory))
            fs.mkdirSync(workingDirectory);
        fs.writeFileSync(path.join(session.outdir, stackManifest.synthesizedStackPath), JSON.stringify(this.toTerraform(), undefined, 2));
    }
}
exports.TerraformStack = TerraformStack;
_a = JSII_RTTI_SYMBOL_1;
TerraformStack[_a] = { fqn: "cdktf.TerraformStack", version: "0.4.1" };
function terraformElements(node, into = []) {
    if (node instanceof terraform_element_1.TerraformElement) {
        into.push(node);
    }
    for (const child of constructs_1.Node.of(node).children) {
        // Don't recurse into a substack
        if (TerraformStack.isStack(child)) {
            continue;
        }
        terraformElements(child, into);
    }
    return into;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQTRFO0FBQzVFLHVDQUFtQztBQUNuQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDJEQUF1RDtBQUN2RCxpQ0FBbUM7QUFDbkMsNkRBQXlEO0FBQ3pELHlDQUErRjtBQUMvRiw2Q0FBZ0Q7QUFHaEQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDOzs7O0FBT3hELE1BQWEsY0FBZSxTQUFRLHNCQUFTOzs7O0lBSTNDLFlBQVksS0FBZ0IsRUFBRSxFQUFVO1FBQ3RDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFKRixpQkFBWSxHQUFRLEVBQUUsQ0FBQTtRQU1yQyxJQUFJLENBQUMsWUFBWSxHQUFHLGlCQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQTtRQUUvRCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDOzs7O0lBRU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFNO1FBQzFCLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxPQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxDQUFDLENBQUM7SUFDbkUsQ0FBQzs7OztJQUVNLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBcUI7UUFDcEMsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFMUIsU0FBUyxPQUFPLENBQUMsQ0FBYTtZQUM1QixJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzdCLE9BQU8sQ0FBQyxDQUFDO2FBQ1Y7WUFF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LFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUU3QyxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUNsRixJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQztZQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVyRSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsb0JBQW9CLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwSSxDQUFDOztBQXJJSCx3Q0FzSUM7OztBQUVELFNBQVMsaUJBQWlCLENBQUMsSUFBZ0IsRUFBRSxPQUEyQixFQUFFO0lBQ3hFLElBQUksSUFBSSxZQUFZLG9DQUFnQixFQUFFO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakI7SUFFRCxLQUFLLE1BQU0sS0FBSyxJQUFJLGlCQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRTtRQUMxQyxnQ0FBZ0M7UUFDaEMsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQUUsU0FBUztTQUFFO1FBRWhELGlCQUFpQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCwgSVN5bnRoZXNpc1Nlc3Npb24sIE5vZGUgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tICcuL190b2tlbnMnXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgVGVycmFmb3JtRWxlbWVudCB9IGZyb20gJy4vdGVycmFmb3JtLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IFRlcnJhZm9ybVByb3ZpZGVyIH0gZnJvbSAnLi90ZXJyYWZvcm0tcHJvdmlkZXInO1xuaW1wb3J0IHsgRVhDTFVERV9TVEFDS19JRF9GUk9NX0xPR0lDQUxfSURTLCBBTExPV19TRVBfQ0hBUlNfSU5fTE9HSUNBTF9JRFMgfSBmcm9tICcuL2ZlYXR1cmVzJztcbmltcG9ydCB7IG1ha2VVbmlxdWVJZCB9IGZyb20gJy4vcHJpdmF0ZS91bmlxdWUnO1xuaW1wb3J0IHsgTWFuaWZlc3QgfSBmcm9tICcuL21hbmlmZXN0J1xuXG5jb25zdCBTVEFDS19TWU1CT0wgPSBTeW1ib2wuZm9yKCdja2R0Zi9UZXJyYWZvcm1TdGFjaycpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhZm9ybVN0YWNrTWV0YWRhdGEge1xuICByZWFkb25seSBzdGFja05hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgVGVycmFmb3JtU3RhY2sgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xuICBwcml2YXRlIHJlYWRvbmx5IHJhd092ZXJyaWRlczogYW55ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBjZGt0ZlZlcnNpb246IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuY2RrdGZWZXJzaW9uID0gTm9kZS5vZih0aGlzKS50cnlHZXRDb250ZXh0KCdjZGt0ZlZlcnNpb24nKVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNUQUNLX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNTdGFjayh4OiBhbnkpOiB4IGlzIFRlcnJhZm9ybVN0YWNrIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIFNUQUNLX1NZTUJPTCBpbiB4O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBvZihjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpOiBUZXJyYWZvcm1TdGFjayB7XG4gICAgcmV0dXJuIF9sb29rdXAoY29uc3RydWN0KTtcblxuICAgIGZ1bmN0aW9uIF9sb29rdXAoYzogSUNvbnN0cnVjdCk6IFRlcnJhZm9ybVN0YWNrICB7XG4gICAgICBpZiAoVGVycmFmb3JtU3RhY2suaXNTdGFjayhjKSkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IE5vZGUub2YoYylcblxuICAgICAgaWYgKCFub2RlLnNjb3BlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhY2sgY291bGQgYmUgaWRlbnRpZmllZCBmb3IgdGhlIGNvbnN0cnVjdCBhdCBwYXRoICcke05vZGUub2YoY29uc3RydWN0KS5wYXRofSdgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9sb29rdXAobm9kZS5zY29wZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFkZE92ZXJyaWRlKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXJyOiBhbnkgPSB0aGlzLnJhd092ZXJyaWRlcztcblxuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKSE7XG5cbiAgICAgIC8vIGlmIHdlIGNhbid0IHJlY3Vyc2UgZnVydGhlciBvciB0aGUgcHJldmlvdXMgdmFsdWUgaXMgbm90IGFuXG4gICAgICAvLyBvYmplY3Qgb3ZlcndyaXRlIGl0IHdpdGggYW4gb2JqZWN0LlxuICAgICAgY29uc3QgaXNPYmplY3QgPSBjdXJyW2tleV0gIT0gbnVsbCAmJiB0eXBlb2YoY3VycltrZXldKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoY3VycltrZXldKTtcbiAgICAgIGlmICghaXNPYmplY3QpIHtcbiAgICAgICAgY3VycltrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBjdXJyW2tleV07XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBsYXN0S2V5ID0gcGFydHMuc2hpZnQoKSE7XG4gICAgY3VycltsYXN0S2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGdldExvZ2ljYWxJZCh0ZkVsZW1lbnQ6IFRlcnJhZm9ybUVsZW1lbnQgfCBOb2RlKTogc3RyaW5nIHtcbiAgICAvLyB3cmFwIHRoZSBhbGxvY2F0aW9uIGZvciBmdXR1cmUgcmVuYW1pbmcgc3VwcG9ydFxuICAgIHJldHVybiB0aGlzLmFsbG9jYXRlTG9naWNhbElkKHRmRWxlbWVudCk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwcm90ZWN0ZWQgYWxsb2NhdGVMb2dpY2FsSWQodGZFbGVtZW50OiBUZXJyYWZvcm1FbGVtZW50IHwgTm9kZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgbm9kZSA9IHRmRWxlbWVudCBpbnN0YW5jZW9mIFRlcnJhZm9ybUVsZW1lbnQgPyB0ZkVsZW1lbnQuY29uc3RydWN0Tm9kZSA6IHRmRWxlbWVudDtcbiAgICBjb25zdCBzdGFjayA9IHRmRWxlbWVudCAgaW5zdGFuY2VvZiBUZXJyYWZvcm1FbGVtZW50ID8gdGZFbGVtZW50LmNka3RmU3RhY2sgOiB0aGlzO1xuXG4gICAgbGV0IHN0YWNrSW5kZXg7XG4gICAgaWYgKG5vZGUudHJ5R2V0Q29udGV4dChFWENMVURFX1NUQUNLX0lEX0ZST01fTE9HSUNBTF9JRFMpKSB7XG4gICAgICBzdGFja0luZGV4ID0gbm9kZS5zY29wZXMuaW5kZXhPZihzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhY2tJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5vZGUuc2NvcGVzLnNsaWNlKHN0YWNrSW5kZXggKyAxKS5tYXAoYyA9PiBOb2RlLm9mKGMpLmlkKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPiAwID8gbWFrZVVuaXF1ZUlkKGNvbXBvbmVudHMsIG5vZGUudHJ5R2V0Q29udGV4dChBTExPV19TRVBfQ0hBUlNfSU5fTE9HSUNBTF9JRFMpKSA6ICcnO1xuICB9XG5cbiAgcHVibGljIGFsbFByb3ZpZGVycygpOiBUZXJyYWZvcm1Qcm92aWRlcltdIHtcbiAgICBjb25zdCBwcm92aWRlcnM6IFRlcnJhZm9ybVByb3ZpZGVyW10gPSBbXTtcblxuICAgIGNvbnN0IHZpc2l0ID0gYXN5bmMgKG5vZGU6IElDb25zdHJ1Y3QpID0+IHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGVycmFmb3JtUHJvdmlkZXIpIHtcbiAgICAgICAgcHJvdmlkZXJzLnB1c2gobm9kZSlcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBOb2RlLm9mKG5vZGUpLmNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdCh0aGlzKVxuXG4gICAgcmV0dXJuIHJlc29sdmUodGhpcywgcHJvdmlkZXJzKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1RlcnJhZm9ybSgpOiBhbnkge1xuICAgIGNvbnN0IHRmID0ge1xuICAgICAgXCIvL1wiOiB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdmVyc2lvbjogdGhpcy5jZGt0ZlZlcnNpb24sXG4gICAgICAgICAgc3RhY2tOYW1lOiBOb2RlLm9mKHRoaXMpLmlkLFxuICAgICAgICB9IGFzIFRlcnJhZm9ybVN0YWNrTWV0YWRhdGFcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0ZXJyYWZvcm1FbGVtZW50cyh0aGlzKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBlbGVtZW50cy5tYXAoZSA9PiByZXNvbHZlKHRoaXMsIGUudG9UZXJyYWZvcm0oKSkpO1xuXG4gICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBmcmFnbWVudHMpIHtcbiAgICAgIGRlZXBNZXJnZSh0ZiwgZnJhZ21lbnQpO1xuICAgIH1cblxuICAgIGRlZXBNZXJnZSh0ZiwgdGhpcy5yYXdPdmVycmlkZXMpO1xuXG4gICAgcmV0dXJuIHJlc29sdmUodGhpcywgdGYpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3ludGhlc2l6ZShzZXNzaW9uOiBJU3ludGhlc2lzU2Vzc2lvbikge1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gc2Vzc2lvbi5tYW5pZmVzdCBhcyBNYW5pZmVzdFxuICAgIGNvbnN0IHN0YWNrTWFuaWZlc3QgPSBtYW5pZmVzdC5mb3JTdGFjayh0aGlzKVxuXG4gICAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeSA9IHBhdGguam9pbihzZXNzaW9uLm91dGRpciwgc3RhY2tNYW5pZmVzdC53b3JraW5nRGlyZWN0b3J5KVxuICAgIGlmICghZnMuZXhpc3RzU3luYyh3b3JraW5nRGlyZWN0b3J5KSkgZnMubWtkaXJTeW5jKHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oc2Vzc2lvbi5vdXRkaXIsIHN0YWNrTWFuaWZlc3Quc3ludGhlc2l6ZWRTdGFja1BhdGgpLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRvVGVycmFmb3JtKCksIHVuZGVmaW5lZCwgMikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlcnJhZm9ybUVsZW1lbnRzKG5vZGU6IElDb25zdHJ1Y3QsIGludG86IFRlcnJhZm9ybUVsZW1lbnRbXSA9IFtdKTogVGVycmFmb3JtRWxlbWVudFtdIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXJyYWZvcm1FbGVtZW50KSB7XG4gICAgaW50by5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBOb2RlLm9mKG5vZGUpLmNoaWxkcmVuKSB7XG4gICAgLy8gRG9uJ3QgcmVjdXJzZSBpbnRvIGEgc3Vic3RhY2tcbiAgICBpZiAoVGVycmFmb3JtU3RhY2suaXNTdGFjayhjaGlsZCkpIHsgY29udGludWU7IH1cblxuICAgIHRlcnJhZm9ybUVsZW1lbnRzKGNoaWxkLCBpbnRvKTtcbiAgfVxuXG4gIHJldHVybiBpbnRvO1xufSJdfQ==